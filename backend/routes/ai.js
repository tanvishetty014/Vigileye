const express = require('express');
const Joi = require('joi');
const { authenticate, authorize } = require('../middleware/auth');
const aiService = require('../services/aiService');
const logger = require('../utils/logger');

const router = express.Router();

// Validation schemas
const threatAnalysisSchema = Joi.object({
  type: Joi.string().required(),
  description: Joi.string().optional(),
  severity: Joi.string().valid('low', 'medium', 'high', 'critical').optional(),
  source: Joi.string().optional(),
  timestamp: Joi.date().optional(),
  metadata: Joi.object().optional()
});

const reportGenerationSchema = Joi.object({
  type: Joi.string().required(),
  timePeriod: Joi.string().optional(),
  totalIncidents: Joi.number().optional(),
  criticalIssues: Joi.number().optional(),
  resolvedIssues: Joi.number().optional(),
  pendingIssues: Joi.number().optional(),
  incidents: Joi.array().optional()
});

/**
 * @route   POST /api/ai/analyze-threat
 * @desc    Analyze threat using AI
 * @access  Private (Admin/Analyst only)
 */
router.post('/analyze-threat', authenticate, authorize('admin', 'analyst'), async (req, res) => {
  try {
    const { error, value } = threatAnalysisSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const analysis = await aiService.analyzeThreat(value);

    logger.info(`AI threat analysis completed by user: ${req.user.email}`);

    res.json({
      success: true,
      data: {
        analysis,
        metadata: {
          analyzedAt: new Date().toISOString(),
          analysisType: 'threat_analysis'
        }
      }
    });

  } catch (error) {
    logger.error('AI threat analysis error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to analyze threat'
    });
  }
});

/**
 * @route   POST /api/ai/analyze-breach
 * @desc    Analyze breach data using AI
 * @access  Private (Admin/Analyst only)
 */
router.post('/analyze-breach', authenticate, authorize('admin', 'analyst'), async (req, res) => {
  try {
    const { error, value } = threatAnalysisSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const analysis = await aiService.analyzeBreach(value);

    logger.info(`AI breach analysis completed by user: ${req.user.email}`);

    res.json({
      success: true,
      data: {
        analysis,
        metadata: {
          analyzedAt: new Date().toISOString(),
          analysisType: 'breach_analysis'
        }
      }
    });

  } catch (error) {
    logger.error('AI breach analysis error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to analyze breach'
    });
  }
});

/**
 * @route   POST /api/ai/assess-risk
 * @desc    Assess risk level using AI
 * @access  Private (Admin/Analyst only)
 */
router.post('/assess-risk', authenticate, authorize('admin', 'analyst'), async (req, res) => {
  try {
    const { error, value } = threatAnalysisSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const assessment = await aiService.assessRisk(value);

    logger.info(`AI risk assessment completed by user: ${req.user.email}`);

    res.json({
      success: true,
      data: {
        assessment,
        metadata: {
          assessedAt: new Date().toISOString(),
          assessmentType: 'risk_assessment'
        }
      }
    });

  } catch (error) {
    logger.error('AI risk assessment error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to assess risk'
    });
  }
});

/**
 * @route   POST /api/ai/generate-report
 * @desc    Generate security report using AI
 * @access  Private (Admin/Analyst only)
 */
router.post('/generate-report', authenticate, authorize('admin', 'analyst'), async (req, res) => {
  try {
    const { error, value } = reportGenerationSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const report = await aiService.generateSecurityReport(value);

    logger.info(`AI report generated by user: ${req.user.email}`);

    res.json({
      success: true,
      data: {
        report,
        metadata: {
          generatedAt: new Date().toISOString(),
          reportType: value.type
        }
      }
    });

  } catch (error) {
    logger.error('AI report generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate report'
    });
  }
});

/**
 * @route   POST /api/ai/batch-analyze
 * @desc    Perform batch analysis on multiple threats
 * @access  Private (Admin only)
 */
router.post('/batch-analyze', authenticate, authorize('admin'), async (req, res) => {
  try {
    const { threats } = req.body;

    if (!Array.isArray(threats) || threats.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Threats array is required and must not be empty'
      });
    }

    if (threats.length > 20) {
      return res.status(400).json({
        success: false,
        message: 'Maximum 20 threats allowed per batch'
      });
    }

    const results = await Promise.allSettled(
      threats.map(async (threat, index) => {
        try {
          const { error } = threatAnalysisSchema.validate(threat);
          if (error) {
            throw new Error(error.details[0].message);
          }

          const analysis = await aiService.analyzeThreat(threat);
          return {
            index,
            success: true,
            analysis
          };
        } catch (threatError) {
          logger.error(`Error analyzing threat ${index}:`, threatError);
          return {
            index,
            success: false,
            error: threatError.message
          };
        }
      })
    );

    const successfulAnalyses = results.filter(result => 
      result.status === 'fulfilled' && result.value.success
    );
    const failedAnalyses = results.filter(result => 
      result.status === 'rejected' || !result.value.success
    );

    logger.info(`Batch AI analysis completed: ${successfulAnalyses.length} successful, ${failedAnalyses.length} failed by user: ${req.user.email}`);

    res.json({
      success: true,
      data: {
        results: results.map(result => 
          result.status === 'fulfilled' ? result.value : {
            success: false,
            error: result.reason?.message || 'Unknown error'
          }
        ),
        summary: {
          total: threats.length,
          successful: successfulAnalyses.length,
          failed: failedAnalyses.length,
          processedAt: new Date().toISOString()
        }
      }
    });

  } catch (error) {
    logger.error('Batch AI analysis error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to perform batch analysis'
    });
  }
});

/**
 * @route   GET /api/ai/capabilities
 * @desc    Get AI service capabilities
 * @access  Private
 */
router.get('/capabilities', authenticate, async (req, res) => {
  try {
    const capabilities = {
      threatAnalysis: {
        description: 'Analyze security threats and incidents',
        inputs: ['type', 'description', 'severity', 'source', 'timestamp', 'metadata'],
        outputs: ['riskScore', 'threatLevel', 'recommendations', 'keyFindings', 'confidence']
      },
      breachAnalysis: {
        description: 'Specialized analysis for data breach incidents',
        inputs: ['type', 'description', 'severity', 'source', 'timestamp', 'metadata'],
        outputs: ['attackVector', 'impactAssessment', 'responseActions', 'riskScore']
      },
      riskAssessment: {
        description: 'Comprehensive risk evaluation and scoring',
        inputs: ['type', 'description', 'severity', 'source', 'timestamp', 'metadata'],
        outputs: ['businessImpact', 'technicalRisk', 'complianceRisk', 'mitigationPriority']
      },
      reportGeneration: {
        description: 'Generate comprehensive security reports',
        inputs: ['type', 'timePeriod', 'incidents', 'metrics', 'statistics'],
        outputs: ['executiveSummary', 'metrics', 'incidentAnalysis', 'recommendations']
      }
    };

    res.json({
      success: true,
      data: {
        capabilities,
        metadata: {
          serviceStatus: process.env.OPENAI_API_KEY ? 'active' : 'fallback_mode',
          model: 'gpt-3.5-turbo',
          maxTokens: 1000,
          temperature: 0.3,
          supportedLanguages: ['en']
        }
      }
    });

  } catch (error) {
    logger.error('Get AI capabilities error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch AI capabilities'
    });
  }
});

/**
 * @route   GET /api/ai/status
 * @desc    Get AI service status
 * @access  Private (Admin only)
 */
router.get('/status', authenticate, authorize('admin'), async (req, res) => {
  try {
    const status = {
      service: 'AI Service',
      status: process.env.OPENAI_API_KEY ? 'active' : 'fallback_mode',
      apiKeyConfigured: !!process.env.OPENAI_API_KEY,
      model: 'gpt-3.5-turbo',
      fallbackMode: !process.env.OPENAI_API_KEY,
      lastChecked: new Date().toISOString()
    };

    // Test AI service if API key is configured
    if (process.env.OPENAI_API_KEY) {
      try {
        await aiService.analyzeThreat({
          type: 'test',
          description: 'Test analysis',
          severity: 'low',
          source: 'health_check',
          timestamp: new Date()
        });
        status.healthCheck = 'passed';
      } catch (testError) {
        status.healthCheck = 'failed';
        status.healthCheckError = testError.message;
      }
    } else {
      status.healthCheck = 'skipped';
      status.healthCheckReason = 'API key not configured';
    }

    res.json({
      success: true,
      data: {
        status
      }
    });

  } catch (error) {
    logger.error('Get AI status error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch AI service status'
    });
  }
});

/**
 * @route   POST /api/ai/test
 * @desc    Test AI service with sample data
 * @access  Private (Admin only)
 */
router.post('/test', authenticate, authorize('admin'), async (req, res) => {
  try {
    const testData = {
      type: 'phishing',
      description: 'Suspicious email campaign detected targeting employees with malicious attachments',
      severity: 'high',
      source: 'email_security',
      timestamp: new Date(),
      metadata: {
        affectedUsers: 150,
        campaignType: 'spear_phishing',
        indicators: ['malicious_attachment', 'suspicious_sender', 'urgent_tone']
      }
    };

    const startTime = Date.now();
    const analysis = await aiService.analyzeThreat(testData);
    const endTime = Date.now();

    res.json({
      success: true,
      data: {
        testData,
        analysis,
        performance: {
          responseTime: `${endTime - startTime}ms`,
          timestamp: new Date().toISOString()
        }
      }
    });

  } catch (error) {
    logger.error('AI service test error:', error);
    res.status(500).json({
      success: false,
      message: 'AI service test failed',
      error: error.message
    });
  }
});

module.exports = router;
